require 'wayness/way_point_pair'
require 'wayness/side_point_manager'
require 'wayness/surface_component'
require 'wayness/way_pathing'
require 'utils/pair_region_lookup'
require 'utils/cache_lookup'
require 'wayness/lane'
require 'wayness/way_grouping_integrator'
require 'utils/basic_utils'
require 'utils/remote_cache_lookup'

# A collection of ways with the same Way_Definition
#
# Author::    Andy Likuski (andy@likuski.org)
# License::   Distributes under the same terms as Ruby
class Way_Grouping < Array
  include Basic_Utils
  include Way_Pathing
  include Way_Grouping_Integrator

  attr_reader :unique_id, :linked_way_network, :way_node_lookup, :way_class, :dual_ways, :continuous_way_sets, :entity_map, :way_point_pair_region_lookup, :path_lookup, :dual_way_by_way_lookup, :dual_way_by_way_id_lookup

  # TODO put these in geometry_utils
  CW_KEY = :clockwise
  CCW_KEY = :counterclockwise
  ROTATE_LOOKUP = {:counterclockwise=> Geometry_Utils::CCW_KEY, :clockwise=> Geometry_Utils::CW_KEY}
  REVERSE_ROTATE = { CW_KEY => CCW_KEY, CCW_KEY => CW_KEY }
  # Used to store attribute data about the Way_Grouping and its subordinates
  ATTRIBUTE_DICTIONARY_KEY = 'way_grouping'
  ATTRIBUTE_ID_KEY = 'id'
  ATTRIBUTE_WAY_CLASS_KEY = 'way_class'

  # Creates a Way_Grouping of the given Way class. The Ways provided must be unidirectional with a reference to their reverse counterpart available via Way.reverse_way. All the Ways and reverse Ways will be included in the Way_Grouping
  # The optional unique_id indicates that the way_grouping is being unmarshalled and should behave accordingly
  def initialize(way_class, ways, unique_id=nil)
    $selfwg=self
    @way_class = way_class
    # Initialize the underlying array with both the ways and their reverse counterparts
    # Skip the reverse ways if we're recreating an existing way_grouping
    super(ways + (unique_id ? [] : ways.map{|way| way.reverse_way}))
    # Creates a unique id for the instance for storage purposes
    # Note that the ways can cange so this isn't a hash key for the way. USe hash() for that
    @unique_id = unique_id || [self.map {|way| way.hash}.hash, Time.now.hash].hash
    # Reference to the default Surface_Component instance that contains the parent Sketchup::ComponentInstance associated with this Way_Group. The default Surface_Component uses the properties of the way_class to render the surface.
    # This isn't initialized immediately so that Way_Grouping can be initialized outside Sketchup, since this relies on the Sketchup Model to be initialized.
    @surface_component=nil
    init_data_structures()
  end

  # This initializes all cache data and stores the way data to the model to reconstruct the way_grouping when the model is closed and reopened. This method is called when the way_grouping is created, when it is unmarshalled from the model attribute data or normal unmarshalling, and whenever the way data is changed in Way_Grouping_Integrator.
  def init_data_structures
    # Create a network of linked_ways sharing the same start point. The data is a hash keyed by the point's hash and valued by a hash that is keyed by each linked_ways's hash and valued by the linked_way itself
    # {point_hash=>{way_hash=>linked_way, way_hash=>linked_way,...},...}
    Rescape::Config.log.info("create_linked_ways_network()")
    @linked_way_network = create_linked_ways_network()
    # Creates a lookup of Way_Node by way_hash
    Rescape::Config.log.info("make_way_hash_to_way_node_lookup")
    @way_hash_to_way_node_lookup = make_way_hash_to_way_node_lookup()
    # Extracts a list of all unique Way_Nodes
    Rescape::Config.log.info("extract way nodes")
    @way_nodes = @way_hash_to_way_node_lookup.values.uniq
    Rescape::Config.log.info("done")

    # bi-directional linked ways
    @dual_ways = all_dual_ways
    # Follow sets of linked_ways by connected to the closest neighbor in the counter-clockwise direction
    # This is needed for rendering
    @continuous_way_sets = get_continuous_way_sets

    # Mapping functions to associate Sketchup entities with our objects
    @entity_map = Entity_Map.new(self)

    # Defines a cache for storing solved way paths.in memory and to external files (so they can be generated by an external process)
    @path_lookup = create_path_lookup()
    # Defines a cache for looking up dual_ways by way
    @dual_way_by_way_lookup = Cache_Lookup.new('dual_way_by_way')
    @dual_way_by_way_id_lookup = Cache_Lookup.new('dual_way_by_way_id')
    cache_dual_ways_by_way()

    # Caching of way_point_pairs and way_points
    @all_way_point_pairs = self.map {|way| way.way_point_pairs}.shallow_flatten
    @way_point_pair_region_lookup = Pair_Region_Lookup.new(all_way_point_pairs)
    @hash_to_way_point_pair = all_way_point_pairs.to_hash_values {|way_point_pair| way_point_pair.hash}
    @hash_to_way_point = all_way_points.to_hash_values {|way_point_pair| way_point_pair.hash}

    # Gaches for storing dynamic data sets
    @side_point_manager_lookup = Cache_Lookup.new('side_point_manager')
    @ad_hoc_surface_component_lookup = Cache_Lookup.new('ad_hoc_surface_component')

    # The following may only be done within the Sketchup context (not by external processes)
    if (Rescape::Config.in_sketchup?)
      remote_solve_all()

      # Serialize the way data to an attribute of the model. This allows the way data to be reloaded from the model when it is reopened.
      if (way_class.save_to_model?)
        store_to_attribute(Sketchup.active_model)
      end
    end

    Rescape::Config.log.info("Finished Initializing way_grouping data for way_class #{@way_class} with #{length} ways")
  end

  def create_path_lookup
    Remote_Cache_Lookup.new(
      'solved_paths',
        # Solved paths are cached by the first and last dual_way of the path (the first way id of the dual_way is used since dual_ways and ways don't have reliable hashing inside and outside the Sketchup environment.)
        lambda {|dual_way_path| dual_way_path.extremes.map {|dual_way|
          dual_way.unique_id}.join('_')},
        lambda {
          # Get or restart the server
          remote_server = Rescape::Setup.get_remote_server()
          # start resolving way_groupings if the server doesn't contain this way_grouping
          # TODO we could move this to a higher level so it doesn't have to run multiple times per tool use
          if (remote_server && !remote_server.started_solving_way_grouping?(self.unique_id))
            Rescape::Config.log.warn("Resolving paths for way_grouping #{self.inspect}")
            begin
              remote_server.solve_all(self)
            rescue
              # if the remote server is down it will attempt to start whenever it is request to solve a path
              Rescape::Config.log.warn("Failed to start solve_all remotely for way_grouping #{way_grouping.inspect}")
            end
          end
          remote_server
        },
        self.unique_id
    )
  end

  # Allows the path_lookup cache to be customize. This is only for use by external processes that need to cache to file
  def override_path_lookup(path_lookup)
    @path_lookup = path_lookup
  end

  # Invalidates the relationships with the Sketchup entities and forces the way_grouping to regenerate them
  def invalidate
    @entity_map.invalidate()
  end

  # Removes bad data, such as deleted edges. The caches will be invalidated if any bad data is found
  def purge
    entity_map.purge()
  end

  # Creates a special case empty way_grouping not associated to any way_class
  def self.create_empty_and_unclassified_way_grouping
    Way_Grouping.new(Lane, [])
  end

  def is_unclassified_way_grouping?
    @way_class==Lane
  end

  def is_unclassified_initial_way_grouping?
    @way_class==Lane && self.length == 0
  end

  # Cache each dual way by both ways it represents
  def cache_dual_ways_by_way
    @dual_ways.each {|dual_way|
      dual_way.linked_ways.each {|linked_way|
        @dual_way_by_way_lookup.add(linked_way.way, dual_way)
        @dual_way_by_way_id_lookup.add(linked_way.way.id, dual_way)
      }
    }
  end

  # Generates side_points for the given Lambda_Wrapper and returns a Side_Point_Manager containing the side_points
  # The results are cached
  def side_point_manager(transformation_lambda_wrapper=nil)
    # Use the continuous_way_sets to generate all the side points of the ways
    @side_point_manager_lookup.find_or_create(transformation_lambda_wrapper) {|transformation_lambda_w|
      Side_Point_Manager.merge(
        @continuous_way_sets.map {|continuous_ways|
          continuous_ways.side_point_manager(transformation_lambda_w)
        })
    }
  end

  # Gets or creates the way_grouping's default Surface_Component
  def surface_component
    get_or_create_surface_component()
  end

  # Optionally defines a transformation to transform the component_instance once it is drawn
  def component_instance_transformation
    nil
  end

  # Restores the surface_component using the given Sketchup component. This is used to restore the @surface_component of a Way_Grouping that is itself restored when an existing model is reopened.
  def restore_surface_component(surface_component_instance)
    if (@surface_component)
      # Remove the existing component_instance from the model
      @surface_component.erase_from_model(active_model)
    end
    @surface_component = Surface_Component.new(active_model, self, nil, nil, surface_component_instance)
  end

  # Simply calls surface_component.component_instance to verify that the component_instance exists, which may cause it to be searched for and found if it got lost via a delete and undo
  def verify_surface_component
    !@surface_component.component_instance_deleted? ||
    @surface_component.component_instance != nil
  end

  def get_or_create_surface_component()
    if (@surface_component)
      verify_surface_component
    else
      @surface_component = Surface_Component.new(active_model, self) unless @surface_component
    end
    @surface_component
  end

  # Create a new Way_Grouping of this Way_Grouping's way_class with the following point sets which will be converted to ways
  def clone_with_new_ways(ways)
    self.class.new(@way_class, ways)
  end


  # Creates a Surface_Component for this Way_Grouping with a custom transformation of the way_points. This is used in cases of a user defined way_grouping whose path width are dynamically decided by the user.
  def make_ad_hoc_surface_component(transformation_lambda_wrapper, way_preprocessor=nil)
    @ad_hoc_surface_component_lookup.find_or_create(transformation_lambda_wrapper) {|transformation_lambda_w|
      Surface_Component.new(active_model, self, transformation_lambda_w, way_preprocessor)
    }
  end

  # Specially serializes the Way_Grouping data to the given model as an attribute. Attributes have limitations in the type of data and length that can be stored.
  def store_to_attribute(model)
    ways = self.map {|way| Marshal.dump(way).bin2hex}
    way_class = Marshal.dump(@way_class)
    # Store the items as an array, since hashing is not supported
    model.set_attribute(self.class::ATTRIBUTE_DICTIONARY_KEY, @unique_id, [ways, way_class])
  end

  # Loads the Way_Grouping from the given model based on the unique_id. The serialized data is stored as an attribute of the model.
  def self.load_from_attribute(model, unique_id)
    marshalled_data =  model.get_attribute(self::ATTRIBUTE_DICTIONARY_KEY, unique_id).or_if_nil {raise "No Way_Grouping data found in the model with id #{unique_id}"}
    ways = marshalled_data[0].map {|marshalled_way|
      begin
        Marshal.load(marshalled_way.hex2bin)
      rescue
        raise "Could not unmarshal way of way_grouping of unique_id #{unique_id}"
      end
    }
    way_class = Marshal.load(marshalled_data[1])
    raise "way_grouping of unique_id #{unique_id} was not serialized in the model" unless ways
    self.new(way_class, ways, unique_id)
  end

  # Marshals the essential way_grouping data. No cache data is dumped, since it can be regenerated.
  def marshal_dump
    {:ways=>self.map, :way_class=>@way_class, :unique_id=>@unique_id}
  end

  # Loads the way_grouping from a serialized form created by marshal_dump
  def marshal_load(hash)
    ways = adjust_reverse_ways_to_match(hash[:ways])
    way_class = hash[:way_class]
    unique_id = hash[:unique_id]
    initialize(way_class, ways, unique_id)
  end

  def adjust_reverse_ways_to_match(ways)
    ways.each {|way| way.update_reverse_way(ways.find {|matching_way| matching_way.hash==way.reverse_way.hash})}
  end

  # Returns a flattened list of the way_point_pairs of all ways
  def all_way_point_pairs
    @all_way_point_pairs
  end

  def all_way_points
    self.map {|way| way.as_way_points}.shallow_flatten
  end

  # Finds the closest way_point_pair to the point efficiently by caching pairs by region
  # Looks at both edges and way_point_pairs
  def closest_way_point_pair_to_point(point)
    @entity_map.closest_way_point_pair_to_point(point)
  end

  # Returns way_point_pairs that match a set of ordered points
  def way_point_pairs_from_ordered_points(points)
    points.map_with_subsequent().map {|point_pair| }
  end

  # Determines whether or not the way_point_pair with the given hash belongs to this way_grouping
  def way_point_pair_is_member?(way_point_pair_hash)
    @hash_to_way_point_pair[way_point_pair_hash] != nil
  end

  # Returns the way_point_pair of with the given hash
  def find_way_point_pair_by_hash(hash)
    raise "Expected hash #{hash} in @hash_to_way_point_pair but didn't find it" unless @hash_to_way_point_pair.member?(hash)
    @hash_to_way_point_pair[hash]
  end

  def find_way_point_by_hash(hash)
    raise "Expected hash #{hash} in @hash_to_way_point but didn't find it" unless @hash_to_way_point.member?(hash)
    @hash_to_way_point[hash]
  end

  # Find the Dual_Way corresponding to the given way
  def dual_way_from_way(way)
    @dual_way_by_way_lookup[way]
  end

  def dual_way_from_way_id(way_id)
    @dual_way_by_way_id_lookup[way_id]
  end

  def way_from_hash(way_hash)
    self.find {|way| way.hash==way_hash}
  end

  # Uses the properties of the underlying way_class and/or surface_component to determine to "top" of the way_grouping at the given point. The default behavior is to find the closest way
  # The reference_point represents a point based on the user's cursor
  def max_z_at_point(point, reference_point)
    # By default just base the height on the cursor point height
    [point.z, reference_point.z].max
  end

  def draw_center_lines
    group = Sketchup.active_model.entities.add_group
    self.each {|way| way.draw_center_line(group)}
  end

  # Draws the sides of the ways by combining continuous sides and then draw each continuous side as a Sketchup Component
  # TODO rename this to render or something
  def draw
    if (!(@surface_component && @surface_component.component_instance_rendered?)) # don't redraw
      Rescape::Config.log.info("Creating surface component")
      surface_component = get_or_create_surface_component()
      Rescape::Config.log.info("Drawing surface component")
      surface_component.draw
      Rescape::Config.log.info("Finished drawing surface component")
      surface_component
    end
  end

  def delete_drawing
    @surface_component.erase_from_model(Sketchup.active_model) if @surface_component
    @surface_component = nil
  end

  # Indicates if the surface_component has been erased by the user or by some other means
  def deleted?
    !@surface_component || @surface_component.component_instance_deleted?
  end

  # Draw selected center line edges that are part of this way_grouping. This is for testing
  def draw_selected_center_lines
    Way_Grouping.new(way_class, self.find_all {|way|
      way_point_pairs = Data_Pair.find_all_matches(way.way_point_pairs, Sketchup.active_model.selection.find_all {|e| e.typename=='Edge'})
      way_point_pairs.length > 0
    }).draw
  end

  # Hashes based on way_class and dual_ways so that two Way_Groups with the same ways in different directions are treated as identical
  def hash
    [@way_class.hash, @dual_ways.hash].hash
  end

  def ==(other)
    self.hash == other.hash
  end

  def inspect
     "#{self.class} of way_class #{self.way_class} with #{self.length} ways and hash #{self.hash}"
  end

end